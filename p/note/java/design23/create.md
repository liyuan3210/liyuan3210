# 创建型模式

## 1.单例模式（８种实　现方式）

１）．饿汗式（静态常量）－＞　推荐

２）．饿汗式（静态代码块）

３）．懒汗式（线程不安全）

４）．懒汗式（线程安全，同步方法）

５）．懒汗式（线程安全，同步代码块）

６）．双重检查　－＞	推荐

７）．静态内部类　－＞	推荐

８）．枚举	－＞　推荐

实例：com.liyuan3210.design23.create.singleton2

## 2.抽象工厂模式

看一个披萨的项目:要便于披萨种类的扩展,要便于维护
1>披萨的种类很多(比如 GreekPizz、CheesePizz 等)
2>披萨的制作有 prepare,bake, cut, box
3>完成披萨店订购功能。

1).简单工厂模式

实例：com.liyuan3210.design23.create.factory2.simplefactory

1.1>使用传统方法完成批萨问题：OrderPizza.java（注释掉打代码）

```
缺点是违反了设计模式的ocp原则,即对扩展开放,对修改关闭。即当我们给类增
加新功能的时候,尽量不修改代码,或者尽可能少修改代码.
方案：使用“简单工厂方法”解决
```

1.2>使用简单工厂方法完成：OrderPizza.java

```
简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。
```

1.3>使用静态类：OrderPizza2.java



2).工厂方法模式

实例：com.liyuan3210.design23.create.factory2.factorymethod

```
使用简单工厂模式,创建不同的简单工厂类,比如BJPizzaSimpleFactory、
LDPizzaSimpleFactory 等等.从当前这个案例来说,也是可以的,但是考虑到项目的
规模,以及软件的可维护性、可扩展性并不是特别好

披萨项目新的需求:客户在点披萨时,可以点不同口味的披萨,比如 北京的奶酪pizza、
北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。
```

3).抽象工厂模式

实例：com.liyuan3210.design23.create.factory2.absfactory

```
1> 抽象工厂模式:定义了一个interface用于创建相关或有依赖关系的对象簇,而无需
指明具体的类
2> 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
3> 从设计层面看,抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。
4> 将工厂抽象成两层,AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以
根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇,
更利于代码的维护和扩展。
```

## 3.原型模式

现在有一只羊tom,姓名为: tom, 年龄为:1,颜色为:白色,请编写程序创建和tom羊 属性完全相同的10只羊。

1)原始方法实现,使用new方式

原始方式好理解，创建对象时总要获取原始对象属性，如果创建复杂对象效率底下。

总是要初始化对象，而不是动态获得对象运行时的状态，不够灵活

2）原型模式方法

Java中Object类是所有类的根类,Object类提供了一个clone()方法,该方法可以
将一个Java对象复制一份,但是需要实现clone的Java类必须要实现一个接口Cloneable,
该接口表示该类能够复制且具有复制的能力 => 原型模式

实例：com.liyuan3210.design23.create.prototype2.improve

原型模式类型：

*.浅拷贝

```
1)对于数据类型是基本数据类型的成员变量,浅拷贝会直接进行值传递,也就是将该属性值复制一份给新的对象。
2)对于数据类型是引用数据类型的成员变量,比如说成员变量是某个数组、某个类的对象等,那么浅拷贝会进行引用传递,也就是只是将该成员变量的引用值(内存地址)复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下,在一个对象中修改该成员变量会影响到另一个对象的该成员变量值
前面我们克隆羊就是浅拷贝
```

*.深拷贝

```
1)复制对象的所有基本数据类型的成员变量值
2)为所有引用数据类型的成员变量申请存储空间,并复制每个引用数据类型成员变
量所引用的对象,直到该对象可达的所有对象。也就是说,对象进行深拷贝要对
整个对象进行拷贝
3)深拷贝实现方式1:重写clone方法来实现深拷贝
4)深拷贝实现方式2:通过对象序列化实现深拷贝(推荐)
```

实例：com.liyuan3210.design23.create.prototype2.deepclone
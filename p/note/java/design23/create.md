# 创建型模式

## 1.单例模式（８种实　现方式）

１）．饿汗式（静态常量）－＞　推荐

２）．饿汗式（静态代码块）

３）．懒汗式（线程不安全）

４）．懒汗式（线程安全，同步方法）

５）．懒汗式（线程安全，同步代码块）

６）．双重检查　－＞	推荐

７）．静态内部类　－＞	推荐

８）．枚举	－＞　推荐

实例：com.liyuan3210.design23.create.singleton2

## 2.抽象工厂模式

看一个披萨的项目:要便于披萨种类的扩展,要便于维护
1>披萨的种类很多(比如 GreekPizz、CheesePizz 等)
2>披萨的制作有 prepare,bake, cut, box
3>完成披萨店订购功能。

1).简单工厂模式

实例：com.liyuan3210.design23.create.factory2.simplefactory

1.1>使用传统方法完成批萨问题：OrderPizza.java（注释掉打代码）

```
缺点是违反了设计模式的ocp原则,即对扩展开放,对修改关闭。即当我们给类增
加新功能的时候,尽量不修改代码,或者尽可能少修改代码.
方案：使用“简单工厂方法”解决
```

1.2>使用简单工厂方法完成：OrderPizza.java

```
简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。
```

1.3>使用静态类：OrderPizza2.java



2).工厂方法模式

实例：com.liyuan3210.design23.create.factory2.factorymethod

```
使用简单工厂模式,创建不同的简单工厂类,比如BJPizzaSimpleFactory、
LDPizzaSimpleFactory 等等.从当前这个案例来说,也是可以的,但是考虑到项目的
规模,以及软件的可维护性、可扩展性并不是特别好

披萨项目新的需求:客户在点披萨时,可以点不同口味的披萨,比如 北京的奶酪pizza、
北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza。
```

3).抽象工厂模式

实例：com.liyuan3210.design23.create.factory2.absfactory

```
1> 抽象工厂模式:定义了一个interface用于创建相关或有依赖关系的对象簇,而无需
指明具体的类
2> 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
3> 从设计层面看,抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。
4> 将工厂抽象成两层,AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以
根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇,
更利于代码的维护和扩展。
```

## 3.原型模式

现在有一只羊tom,姓名为: tom, 年龄为:1,颜色为:白色,请编写程序创建和tom羊 属性完全相同的10只羊。

1)原始方法实现,使用new方式

原始方式好理解，创建对象时总要获取原始对象属性，如果创建复杂对象效率底下。

总是要初始化对象，而不是动态获得对象运行时的状态，不够灵活

2）原型模式方法

Java中Object类是所有类的根类,Object类提供了一个clone()方法,该方法可以
将一个Java对象复制一份,但是需要实现clone的Java类必须要实现一个接口Cloneable,
该接口表示该类能够复制且具有复制的能力 => 原型模式

实例：com.liyuan3210.design23.create.prototype2.improve

原型模式类型：

*.浅拷贝

```
1)对于数据类型是基本数据类型的成员变量,浅拷贝会直接进行值传递,也就是将该属性值复制一份给新的对象。
2)对于数据类型是引用数据类型的成员变量,比如说成员变量是某个数组、某个类的对象等,那么浅拷贝会进行引用传递,也就是只是将该成员变量的引用值(内存地址)复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下,在一个对象中修改该成员变量会影响到另一个对象的该成员变量值
前面我们克隆羊就是浅拷贝
```

*.深拷贝

```
1)复制对象的所有基本数据类型的成员变量值
2)为所有引用数据类型的成员变量申请存储空间,并复制每个引用数据类型成员变
量所引用的对象,直到该对象可达的所有对象。也就是说,对象进行深拷贝要对
整个对象进行拷贝
3)深拷贝实现方式1:重写clone方法来实现深拷贝
4)深拷贝实现方式2:通过对象序列化实现深拷贝(推荐)
```

实例：com.liyuan3210.design23.create.prototype2.deepclone

## 4.建造者模式

1)首先使用原始方法实现

1>设计的程序结构,过于简单,没有设计缓存层对象,程序的扩展和维护不好. 也就
是说,这种设计方案,把产品(即:房子) 和 创建产品的过程(即:建房子流程) 封
装在一起,耦合性增强了。
2> 解决方案:将产品和产品建造过程解耦 => 建造者模式.

2)建造者模式

```
基本介绍
1>.建造者模式(Builder Pattern) 又叫生成器模式,是一种对象构建模式。它可以
将复杂对象的建造过程抽象出来(抽象类别),使这个抽象过程的不同实现方
法可以构造出不同表现(属性)的对象。
2>.建造者模式 是一步一步创建一个复杂的对象,它允许用户只通过指定复杂对象
的类型和内容就可以构建它们,用户不需要知道内部的具体构建细节。

建造者模式的四个角色
1) Product(产品角色): 一个具体的产品对象。
2) Builder(抽象建造者): 创建一个Product对象的各个部件指定的 接口/抽象类。
3) ConcreteBuilder(具体建造者): 实现接口,构建和装配各个部件。
4) Director(指挥者): 构建一个使用Builder接口的对象。它主要是用于创建一个
复杂的对象。它主要有两个作用,一是:隔离了客户与对象的生产过程,二是:
负责控制产品对象的生产过程。
```

建造者模式的注意事项和细节：

```
1) 客户端(使用程序)不必知道产品内部组成的细节,将产品本身与产品的创建过程解
耦,使得相同的创建过程可以创建不同的产品对象
2) 每一个具体建造者都相对独立,而与其他的具体建造者无关,因此可以很方便地替
换具体建造者或增加新的具体建造者, 用户使用不同的具体建造者即可得到不同
的产品对象
3) 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法
中,使得创建过程更加清晰,也更方便使用程序来控制创建过程
4) 增加新的具体建造者无须修改原有类库的代码,指挥者类针对抽象建造者类编程,
系统扩展方便,符合 “开闭原则”
5) 建造者模式所创建的产品一般具有较多的共同点,其组成部分相似,如果产品之间
的差异性很大,则不适合使用建造者模式,因此其使用范围受到一定的限制。
6) 如果产品的内部变化复杂,可能会导致需要定义很多具体建造者类来实现这种变化,
导致系统变得很庞大,因此在这种情况下,要考虑是否选择建造者模式.
7) 抽象工厂模式VS建造者模式
抽象工厂模式实现对产品家族的创建,一个产品家族是这样的一系列产品:具有不
同分类维度的产品组合,采用抽象工厂模式不需要关心构建过程,只关心什么产品
由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品,它的主要
目的是通过组装零配件而产生一个新产品
```

实例：com.liyuan3210.design23.create.builder2
# 算法(十种常见算法)

##### 1.二分查找算法

二分查找算法(**非递归**)介绍

```
1>.前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式
2>.二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找
3>二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 < 100 < 2^7)
```

实例（非递归）：com.liyuan3210.dsa.algorithm.binarysearchnorecursion

##### 2.分治算法

问题：汉诺塔算法

分治算法介绍

```
1>.分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……
2>.分治算法可以求解的一些经典问题
二分搜索
大整数乘法
棋盘覆盖
合并排序
快速排序
线性时间选择
最接近点对问题
循环赛日程表
汉诺塔
```

分治算法的基本步骤

```
分治法在每一层递归上都有三个步骤：
分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
合并：将各个子问题的解合并为原问题的解
```

实例(汉诺塔)：com.liyuan3210.dsa.algorithm.dac

##### 3.动态规划算法

问题：背包问题

有一个包，容量4磅。有如下物品：

吉他（G）	重量（1磅）	价格（1500）

音响（S）	 重量（4磅）	价格（3000）

电脑（L）	 重量（3磅）	 价格（2000）

```
要求：
1>.达到的目标为装入的背包的总价值最大，并且重量不超出
2>.装入的物品不能重复
```

动态规划算法介绍

```
1>.动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法
2>.动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。
3>.与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )
4>.动态规划可以通过填表的方式来逐步推进，得到最优解.
```

![](img/dynamic.png)

实例（背包问题）：com.liyuan3210.dsa.algorithm.dynamic

##### 4.KMP算法

暴力匹配算法

```
如果用暴力匹配的思路，并假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有:
1>.如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符
2>.如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。
3>.用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)
暴力匹配算法实现.
```

KMP算法介绍

```
1>.KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法
2>.Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法.
3>.KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间
4>.参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html
```

算法核心

```
暴力匹配是依次读取目标字符串位数与源进行匹配，如果读到不匹配的，置零目标字符串指针，再重新匹配。为了提高效率，通过KMP算法可以跳过没必要已经匹配的字符串。
怎么跳过没必要匹配的字符串？？？
需要通过目标字符串得到`部分匹配表`
```

##### 5.xxxxxx

##### 6.xxxxxx
##### 7.xxxxxx
##### 8.xxxxxx
##### 9.xxxxxx
##### 10.xxxxxx
##### 



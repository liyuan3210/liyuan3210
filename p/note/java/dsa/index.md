# 数据结构与算法

视屏课程:
https://www.bilibili.com/video/BV1B4411H76f?from=search&seid=8541134073371747563

链接: 
https://pan.baidu.com/s/18y3CKb6a5N6f8DCpUH1Pbw 提取码: hnms

当前（总：195，当前：81）

https://www.bilibili.com/video/BV1B4411H76f?p=16

## 一．数据结构与算法

### 内容介绍

应用场景（程序）　＝ 	数据结构	＋　算法

### 一．数据结构分类

#### 线性结构：

数组，队列，链表和栈

```
特点是数据元素之间存在一对一的线性关系

有两种不同存储结构，顺序存储（存储元素是连续的），链式存储（元素不一定是连续的，元素存储相邻的元素地址信息）
```

#### 非线性结构：

二维数组，多维数组，广义表，**树结构，图结构**

**1.稀疏数组(五子棋例子)**

实例：dsa.dataStructures.sparsearray

**2.队列**

实例：dsa.dataStructures.queue

简单队列：com.liyuan3210.dsa.dataStructures.queue.ArrayQueueDemo.java

```
数组模拟队列一个思路，但有问题（数组不能重复使用）
```

环形队列：com.liyuan3210.dsa.dataStructures.queue.CircleArrayQueueDemo.java

```
改进成环形队列（通过取模方式）。算法可以有多种，但这种数据有效个数是lenth-1(因为有个预留空间)
```

**3.链表**

链表方式：
分为，有头链表，无头链表两种

实例：dsa.dataStructures.linkedlist

**单向链表：**

实例：com.liyuan3210.dsa.dataStructures.linkedlist.SingleLinkedListDemo.java

链表排序，添加，删除

面试题：

```
1>求单链表中有效节点个数
2>查找单链表中的倒数K个结点
3>单链表反转(数据结构反转)
4>从头打印单链表(不改变链表数据顺序，使用到了栈Stack)
```

**双向链表：**

实例：com.liyuan3210.dsa.dataStructures.linkedlist.DoubleLinkedListDemo.java

双向链表显示，添加，删除，修改

**单向环形链表（约瑟夫问题）:**

```
Josephu  问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
```

实例：com.liyuan3210.dsa.dataStructures.linkedlist.Josepfu.java

数组取模也可以完成（环形链表）

**4.栈**

使用场景：

子程序的调用 	
处理递归调用
表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
二叉树的遍历。
图形的深度优先(depth一first)搜索法。

实例：dsa.dataStructures.stack

4.1>.数组实现栈 ：ArrayStackDemo.java

4.2>.栈实现计算器：Calculator.java

4.3>.前缀，中缀，后缀表达式规则

每一种表达式有不同方式读取计算规则

```
前缀表达式（波兰表达式）:
中缀:前面实现的都是按照中缀实现的(人比较好理解，但计算机不太容易处理)
后缀（逆波兰表达式）:计算机容易处理的表达式
```

4.4>.中缀表达式转后缀表达式

PolandNotation.java

4.5>.逆波兰计算器完整版

课件ppt第56页

**5.递归使用**

递归能解决的问题：

```
5.1>.各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛)
5.2>.各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.
5.3>将用栈解决的问题-->第归代码比较简洁
```

实例：com.liyuan3210.dsa.dataStructures.recursion

递归机制：

![](img/recursion-1.png)

递归需要遵守的重要规则:

```
*.执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
*.方法的局部变量是独立的，不会相互影响, 比如n变量
*.如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.
*.递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)
*.当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。
```

案例分析：

*.迷宫问题分析：MiGong.java

```
1>.小球得到的路径，和程序设置的找路策略有关即：找路的上下左右的顺序相关
2>.再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化
3>.测试回溯现象
思考: 如何求出最短路径? 
```

*.八皇后问题分析：Queue8.java

```
1>.第一个皇后先放第一行第一列
2>.第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适
3>.继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解
4>.当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.
5>.然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 【示意图】

说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列
```

**6.排序算法**

![](img/sort-1.png)



衡量程序执行时间，**时间复杂度**，衡量

表示方法：T(n)=2n²+7n+6 

由于随着时间频度增加，有些系数可以忽略（参照上面表达式）：

忽略常数项（6忽略），忽略低次项（7n忽略），忽略系数（2n²的2）

最终：T(n²)



常见的时间复杂度（详细见ppt）:

```
1)常数阶O(1)
2)对数阶O(log2n)
3)线性阶O(n)
4)线性对数阶O(nlog2n)
5)平方阶O(n^2)（两个for循环）
6)立方阶O(n^3)（三个for循环）
7)k次方阶O(n^k)
8)指数阶O(2^n)
```



平均时间复杂度和最坏时间复杂度：

![](img/sort-2.png)

什么是`稳定`？

```
注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的
```

6.1.冒泡排序

```
基本介绍
冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。
```

从小到大（第一轮for循环找到最大的），从大到小（第一轮for循环找到最小的）

实例：com.liyuan3210.dsa.dataStructures.sort.BubbleSort.java



6.2.选择排序

```
选择排序思想:

选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：
第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，
第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，
第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。
```

从小到大（第一轮for循环找到最大的），从大到小（第一轮for循环找到最小的）

实例：com.liyuan3210.dsa.dataStructures.sort.SelectSort.java



6.3.插入排序

```
插入排序法思想:

插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。
```

实例：com.liyuan3210.dsa.dataStructures.sort.InsertSort.java



6.4.希尔排序

插入排序存在一定问题，从小到大排序时当最小的数在最右边，会增加处理步骤（缩小增量排序）。

```
希尔排序法基本思想

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止
```

![](img/sort-3.png)Added Added 

插入时有两种方法，**交换法（效率很慢）**，**移位法（效率高）**

实例：com.liyuan3210.dsa.dataStructures.sort.ShellSort.java



6.5.快速排序

快速排序法介绍:

```
快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列
```

![](img/quick_sort.jpg)

实例：com.liyuan3210.dsa.dataStructures.sort.QuickSort.java



6.6.归并排序

归并排序介绍:

```
归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。
```

![](img/meger-1.png)

![](img/meger-2.png)

实例：com.liyuan3210.dsa.dataStructures.sort.MergetSort.java



6.7.基数排序

基数排序(桶排序)介绍:

```
1>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用
2>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法
3>基数排序(Radix Sort)是桶排序的扩展
4>基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。

基数排序基本思想:
将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
```

![](img/sort-4.png)

实例：com.liyuan3210.dsa.dataStructures.sort.RadixSort.java

6.8.时间复杂度比较：

![](img/sort-bijiao.png)



### 二．算法分类

**常见查找算法：**

1.顺序查找（传统一个一个查找）

2.二分查找/折半查找

```
二分查找(必须是有序的)：
   请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示"没有这个数"。

思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000
```

实例：com.liyuan3210.dsa.dataStructures.search.BinarySearch.java

3.插值查找

4.斐波那契查找
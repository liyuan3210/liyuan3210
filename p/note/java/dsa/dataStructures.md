# 数据结构

1.**赫夫曼树**(即是一种数据结构,也是一直算法)

```
基本介绍
1>.给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。
2>.赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
```

赫夫曼树:

```
赫夫曼树几个重要概念和举例说明

1).路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1
2).结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积
3).树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。
4).WPL最小的就是赫夫曼树
```

![](img/huffman-2.png)

```
构成赫夫曼树的步骤：
1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树
2) 取出根节点权值最小的两颗二叉树 
3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  
4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树
```

![](img/huffman-1.png)

实例:com.liyuan3210.dsa.dataStructures.huffmantree

**1.1赫夫曼编码**(压缩与解压):

```
基本介绍

1).赫夫曼编码也翻译为    哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法
2).赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。
3).赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间
4).赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码
```

原理介绍:

```
1).定长编码:数据按照原始要传谁的长度进行传输
2).变长编码:数据按照一定算法进行压缩进行传输,接收时要按照算法规则进行反解码

注意:
这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的, 比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为:
```

**1.2.数据压缩(实例):**

```
传输的 字符串 
1) i like like like java do you like a java    
2)  d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  // 各个字符对应的个数
3)  按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值 
```

![](img/huffman-3.png)

```
4)  根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为0 向右的路径为1 ， 编码如下:
o: 1000   u: 10010  d: 100110  y: 100111  i: 101
a : 110     k: 1110    e: 1111       j: 0000       v: 0001
l: 001          : 01
5) 按照上面的赫夫曼编码，我们的"i like like like java do you like a java"   字符串对应的编码为 (注意这里我们使用的无损压缩)
1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110  通过赫夫曼编码处理  长度为  133
```

**1.3.数据解压(实例):**

```
1). 将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]重写先转成 赫夫曼编码对应的二进制的字符串 "1010100010111..."
2). 赫夫曼编码对应的二进制的字符串 "1010100010111..." =》 对照 赫夫曼编码  =》 "i like like like java do you like a java"
```
赫夫曼编码压缩文件注意事项
```
1).如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件  [举例压一个 .ppt]
2).赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml文件]
3).如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显. 
```

实例:com.liyuan3210.dsa.dataStructures.huffmancode

**2.BST二叉排序树**

二叉排序树介绍

二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，`要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大`。
`特别说明：`如果有相同的值，可以将该节点放在左子节点或右子节点

![](img/bst-1.png)

`中序遍历二叉排序树,数组是一个有序的数组`(从小到大).

二叉树添加(比较简单),删除,删除有点逻辑,大致如下:

![](img/bst-2.png)

```
1).删除叶子节点 (比如：2, 5, 9, 12)
2).删除只有一颗子树的节点 (比如：1)
3).删除有两颗子树的节点. (比如：7, 3，10 )

第一种情况:
删除叶子节点 (比如：2, 5, 9, 12)
思路
(1) 需求先去找到要删除的结点  targetNode
(2)  找到targetNode 的 父结点 parent 
(3)  确定 targetNode 是 parent的左子结点 还是右子结点
(4)  根据前面的情况来对应删除
左子结点 parent.left = null
右子结点 parent.right = null;

第二种情况: 删除只有一颗子树的节点 (代码逻辑问题???)
思路
(1) 需求先去找到要删除的结点  targetNode
(2)  找到targetNode 的 父结点 parent 
(3) 确定targetNode 的子结点是左子结点还是右子结点
(4) targetNode 是 parent 的左子结点还是右子结点
(5) 如果targetNode 有左子结点
5. 1 如果 targetNode 是 parent 的左子结点
parent.left = targetNode.left;
5.2  如果 targetNode 是 parent 的右子结点
parent.right = targetNode.left;
(6) 如果targetNode 有右子结点
6.1 如果 targetNode 是 parent 的左子结点
parent.left = targetNode.right;
6.2 如果 targetNode 是 parent 的右子结点
parent.right = targetNode.right

情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 )
思路
(1) 需求先去找到要删除的结点  targetNode
(2)  找到targetNode 的 父结点 parent 
(3)  从targetNode 的右子树找到最小的结点 或者从 左子数找最大的(???)
(4) 用一个临时变量，将 最小结点的值保存 temp = 11
(5)  删除该最小结点
(6)  targetNode.value = temp
```

实例:com.liyuan3210.dsa.dataStructures.binarysorttree

**3.AVL平衡二叉树**

BST二叉排序树问题分析:

```
左边BST 存在的问题分析:
给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.

1>左子树全部为空，从形式上看，更像一个单链表.
2>插入速度没有影响
3>查询速度明显降低(因为需要依次比较), 不能发挥BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢
解决方案-平衡二叉树(AVL)
```

基本介绍

1>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。
2>具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的**常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树**等。

**平衡二叉树ADD时有三种情况:**

首先要编写获取当前节点,左节点,右节点有几成3个方法 

3.1.左旋转

![](img/avl-1.png)

3.2.右旋转

![](img/avl-2.png)

3.3.双旋转

![](img/avl-3.png)

需要判断条件旋转两次

实例:com.liyuan3210.dsa.dataStructures.avl



